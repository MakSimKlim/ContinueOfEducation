// 230918_поток
//
// Потоки, которые уже предопределены: 
// 
// 1) cin - объект класса istream, связанный со стандартным буферизированным 
// потоком ввода / входным потоком (обычно клавиатура)
// 
// 2) cout - объект класса ostream, связанный со стандарным буферизированным 
// потоком вывода/ выходным потоком (обычно консоль на дисплее)
// 
// 3) cerr - объект класса ostream связанный с небуферизированным входным потоком
// куда направляются сообщения об ошибках
// 
// 4) clog - то же самое, что cerr но буферизован
//

// У нас есть 2 класса для ввода/ вывода: isteram и ostream.
// Класс osteram используют для вывода переопределения операции 
// левого сдвига << (операция помещения в поток)
//
// Класс istream использует для вывода перопрелдления операции
// правого сдвига >> (операции извлечения из потока)
//
// Операции помещения/ извлечения допускают цепочки вызовов, так как
// возврщают  значение ссылки на поток.
// Кламссы istream и ostream перегружают операции помещения и извлечения
// для всех встроенных типов даных. Такая перегрузка позволяет использовать
// единый синтаксис для ввода вывода всех типов.
// Операции помещения и извлечения легко распространяются на
// пользовательские типы данных, достаточно только перегрузить соответствующие
// операторы: 
// [friend] isteram& operator>>(isteram&, <typename>&);
// [friend] osteram& operator>>(isteram&, <typename>&);
//

// Файл - цепочка байтов, у которых есть начало и конец
// Файловые потоки (библиотека): #include <fstream>
// Она реализует следующий функционал:
// Создание файла
// Создание потока
// Открытие файла
// "Присоединение" файла к потоку
// Обмен с файлом с помощью потока
// "Отсоединение" файла от потока
// Закрытие файла
// Уничтожение файла
// Эта библиотека обязательно требует использование using namespace std;
// 
//

// В библиотеке fstream есть три класса для ввода и вывода ланных в файл
// ofstream - для вывода данны в файл
// ifsteram - для ввода данных из файла
// fstream - для чтения и записи данных

// Для каждого из этих трех классов существует по 4 конструктора.
// Рассмотрим на примере fstream:
// fstream() создает поток, не открывая файл
// fstream(
//     const char* name - имя файла
//     int omode - режим открытия
//     int = filebuf::openport - защита файла
// ) - создает поток, открывает файли связывает егго с потоком
// fstream(
//     int f - дескриптор файла
// ) - создает поток и связывает его с уже открытим файлом
// fstream (
//     int f - дескрипторр файла
//     char *buf - буфер
//     int len  - размер буфера
// ) - то же что конструктор выше, но потоку назначается буфер
// 
// 
// Рассмотрим omode подробнее
// enum _Openmode = 
// {
//  in = 0x01, //открыть только для чтения
//  out = 0x02, // открыть только для записи
//  ate = 0x04, // установить указатель на конец файла
//  app = 0x08, // дописывать в коонец файла
//  trunc = 0x10, // усечь файл до нулевой длины
// _Nocreate = 0x40, // если файл не существует. вызвать ошибку
// _Noreplace = 0x80, // если файл уже существует, вызвать ошибку
//  binary = 0x20 - открыть файл для обменаа двоичными данными
// }
// Нужно добавлять ространство имен ios
//  ios::in
//
// Функция для работы с файлами
//  void open(
//  const char* file name - имя файла
//  int mode = dafault - режим открытия
//  int protection = default
// )
//  Вызывается через объект одного из классов файловых потоков
// и зваписывает в него 0 (ноль). в случае ошибки
//
// int close() -очищает буфер потока, отсоединяет поток от файла и закрывает файл
// Вызывается автоматиччески для всех потоков до завершения программы
// istream::read(unsigned char *buf, int len)
// Считывает блок символов
// len - максимальное число символов, извлекаемое в буфер buf
//
// ostream::write(const unsigned char *buf, int n)
// производит запись блока символов.
// n - число символов (включая нуль-символ), которое должно быть помещено в поток
// 
// istream::get(unsigned char&) - считывает один символ из потока
// ostream::put(char) - помещает один символ в поток
//
// istream::get(unsigned char *buf, int n, char c='\n') - извлекает строку из потока
// 
// Во функциях выше, символы извлекаются и помещаются в буфер, покеа не будет
// найден символ ограничитель, или не ,eltn ghjxbnfyj т символов или пока не
// встретится коонец файла. Ограничитель при этом не извлекается и не помещается в буфер
// 
// istream::getline(unsigned char *buf, int n, char c='\n') - извлекает из потока
// строчку, но включая символ ограничитель, в буфер он не ззаносится
// 
// isteram::ignore(int n =1, int d = EOF)
// извлекает без записи в буфер указанное число символов, либо пока не встретится
// ограничитель d
// 
// istream::gcout() -- количество символов извлеченных последней функцией бесформатного ввода
// 
// istream::peek() - позволяет взглянуть на следующий символ - возвращает код символа
// но не извлекает его из потока. Вернет EOF если поток уже пустой
// 
// isteram::putback(char c) - ничего не извлекает из потока
// вместо этого помещает в поток символ с, он становится текущем и будет извлечен из потока следующим
// 
// isteram::seekg(longpos) - устанавливаеет позиции чтениия из потока
// определенную значением аргумента
// 
// isteram::seekg(long off, ios::seek_dir dir) - перемещает позицию
// чтения в направлении, определенном dir
// unum seek_dir {beg, cur, end} - смещение от начала текущей позиции или конца потока
// 
// ostream::seekp(long pos) - устанавливает позицию записи потока
// 
// osteram::seekp(long off, ios::seek_dir dir) - аналогично seekg но для позиции записи
// 
// istream::tellg() -  определяет текущую позицию чтения 
// ostream::tellg() -  определяет текущую позицию записи 
// 
//

//
//

#include <iostream> // поток ввода-ввывода input output stream
#include <iomanip>
#include <conio.h>

#define NUM_COLS 18;
#define NUM_ROWS 24;


using namespace std;

int main()
{
    string path;
    cout << "Input file path:";
    cin >> path;

    int counter = 0, i = 0, j = 0;
    char text[NUM_COLS];

    ifstream input(path.c_str(), ios::in | ios::binary);
    if (!input)
    {
        cout << "Cannot open file for display" << endl;
        return 0;
    }
    cout.setf(ios::uppercase);//вывод большими буквами

    while (!input.eof())
    {
        for (i = 0; (i < NUM_COLS && !input.eof()); i++)
        {
            input.get(text[i]);
        }
        if (i < NUM_COLS)
            i--;

        for (j = 0; j < i;j++)
        {
            if ((unsigned)text[j] < 0x10)
            {
                cout << setw(2) << 0 << hex << (unsigned)text[j];
            }
            else
            {
                cout << setw(3) << hex << (unsigned)text[j];
            }
        }
        for (: j < NUM_COLS;j++)
        {
            cout << "      ";
        }
        cout << "\t";
        for (j = 0; j < i; j++)
        {
            if (text[j] > 31 && text[j] <= 255)
                cout << text[j];
            else
                cout << ".";
        }

        cout << endl;

        if (++counter == NUM_ROWS)
        {
            counter = 0;
            cout << "Press ane key" << flush;

            _getch();
            cout << endl;
        }
    }

    input.close();

    return 0;
}

