// 230906_виртуальные функции
//
// Виртуальные потому что у нескольких разных классов они могут называться одинаково, 
// но нужная реализация вызывается в момент выполнения
//
// Полиморфизм явно проявляется в виртуальных функциях
//
// Ранние(мы знаем что нам нужно заранее) и поздние(не знаем что нам нужно заранее) связывания, 
// а также статичекский и динамичкеский полиморфизм
// Ранние связывания - готовность к конкретным ситуациям (статический полиморфизм)
// Поздние связывания - готовность ко многим ситуациям (динамический полиморфизм), их осуществляют виртуальные функции
// скорость при раннем связывании выше, но при позднем связывании универсальность больше
// Полиморфизм - переопределние наследникам методов родительского класса (статический и динамический)
//
// Чисто виртуальная функция

#include <iostream>

using namespace std;

class A
{
public:
	virtual void v_function();

};

void A :: v_function()
{
	cout << "This is A!" << endl;
}

class B: public A
{
public:
	virtual void v_function();// по сути это перегрузка и переопределение класса В через А

};

void B::v_function()
{
	cout << "This is B!" << endl;
}



class C : public B
{
public:
	//void v_function();//функция не виртуальная, поэтому наследники С не смогут её перегрузить!!!
	virtual void v_function();//функция не виртуальная, поэтому наследники С не смогут её перегрузить!!!

};
void C::v_function()
{
	cout << "This is C!" << endl;
}

class D : public C
{
public:
	//void v_function();//функция не виртуальная, поэтому наследники С не смогут её перегрузить!!!
	virtual void v_function(char letter);//это новая функция отличная от v_function с пустыми параметрами
};
void D::v_function(char letter)
{
	//cout << "This is D!" << endl;
	cout << "This is  "<< letter << "!" << endl;// Выведет результат : "This is C!" 
}
// передаваемые параметры и имя должны совпадать, иначе не будет перегрузки



int main1()
{
	A objA;
	B objB;
	C objC;
	D objD;

	// полиморфизм
	A* objPointer;
	//objPointer = &objC;
	//objPointer = &objB;
	objPointer = &objA;
	objPointer->v_function();// полля и методы от указателя вызывает ->
	objPointer = &objB;
	objPointer->v_function();// полля и методы от указателя вызывает ->
	objPointer = &objC;
	objPointer->v_function();// полля и методы от указателя вызывает ->
	objPointer = &objD;
	objPointer->v_function();// полля и методы от указателя вызывает ->

	// в обратную сторону не работает
	// указатель на наследника не может хранить экземпляр родителя
	// т.к. наследники более узкие по симантике
	//C* objPointerC;
	//objPointerC = &objA;

	return 0;
}

