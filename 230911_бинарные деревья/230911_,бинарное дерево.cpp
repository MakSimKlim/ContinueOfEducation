// 230911_,бинарное дерево
//
// древовидная структура
//
// графы в математике - структура из узлов графов, в которых храняьтся данные, между ними установлкены связи по каким-то отношениям (ребра графа)
//
// Центральный узел - корень. Каждый узел иемеет не более 2х ребер. 
// Узлы к которым ведут эти ребра, называются потомками. От которого отхождят ребра - родитель
// у каждлого узла не более 1 родителя и не более 2х потомков
//
// если у узла нет потомков, то он называется листом
//
// потомки делятся на левого и правого
//
// узел не имеющий родителя, называется корень
// 
// 
// - значение, 
// - указатель на родителя, 
// - указатель на левого потомка, 
// - указатель на правого потмка
//
// каждое поддерево бинарного дерева является деревом, 
// сл-но бинарные деревья состоят из бинарных деревьев и это называется
// рекурсивная структура 
//
// дерево может состоять из единственного узла
//
// Принцип (особенность) заполнения бинарного дерева данными ( отношения больше, меньше): 
// начиная с корня, заканчивая последним листом
// - значение меньше родительского помещается в левого потомка
// - значение больше родительского - в правого потомка
//
// Итак в левой ветке значения - меньше родительского узла
// в правой ветке значения - больше родительского узла
//
// алгоритмы работы с бинарными деревьями как правило рекурсивные,т.к.
// дерево имеет рекурсивную природу
//
// количество уровней называется высота дерева


Алгоритм обхода (вывода содержимого ) на экран

Допустим узел содержит
- Данные
- Родитель: Узел
- Левый_потомок: Узел
- Правый_потомок: Узел

Допустим у нас есть функция Вывод(х)

тогда функция обхода дерева выглядит так:

Обход(Х - текущий узел)
1.Если Х не является пустым: 
   1.1 Обход(Х.Левый_потомок)
   1.2 Вывод(Х)
   1.3 Обход(Х.Правый_потомок)
2.Если Х пустой, выход из Обход()
в этом случае условием выхода из рекурсии становится пустота Х
Так обходится всё дерево

Тогда функция поиска значения выглядит так:
   Поиск(Х - текущий узел, К - искомое значение)
	   1. Если X не является пустым
	      1.1 Если К не равно Х. Данные
	         1.1.1 Если К меньше Х. Данные
	            1.1.1.1 Поиск (Х.Левый потомок, К)
	         1.1.2 Если К больше Х.Данные
	            1.1.2.1 Поиск(Х.Правый потомок, К)
	      1.2 Если К равно Х. Данные, вернуть Х
	   2. Если является, вернуть метку, что данные не найдены

Нахождение мин и макс:
минимум(Х)
1.Пока Х.Левый_потомок не является пустым (пустота определяется в зависимости от языка)
   1.1 Х = Х.Левый_потомок
2.Если Х является пустым, вернуть Х.Родитель

максимум(Х)
1.Пока Х.Правый_протомок не является пустым(пустота определяется в зависимости от языка)
   1.1 Х = Х.Правый_потомок
2.Если Х является пустым, вернуть Х.Родитель

получение следующего элемента(Х), если они упорядочены
1.Если Х.Правый_потомок не является пустымб тогда вернуть Минимум(Х.Правый потомок)
2. Пусть У = Х.Родитель
3. Пока У не является пустым и Х равен Х.Правй потомок
3.1 Х=У
3.2 У=Х
4. Вернуть У

получение Предыдущего элемента(Х), если они упорядочены
1.Если Х.Левый_равый_потомок не является пустымб тогда вернуть Максимум(Х.Левый потомок)
2. Пусть У = Х.Родитель
3. Пока У не является пустым и Х равен Х.Левый_потомок
3.1 Х = У
3.2 У = Х
4. Вернуть У

вставка значений
вставка(ROOT - корень дерева, K - узел, котроый надо вставить)
1.Пусть У является пустым
2.Пусть Х = ROOT
3.Пока Х не является пустым
   3.2 Пусть У=Х
   3.3 Если К.Данные меньше, чем Х.Данные
      3.3.1 Пусть Х равно Х.Левый_потомок
   3.4 Если К.Данные меньше, чем Х.Данные
      3.4.1 Пусть Х равно Х.Правый_потомок
4.Пусть К.Родитель = У / Пусть К.Родитель = Х.Родитель
5.Если У является пустым, пусть ROOt = К
6.Иначе, если У не пустой
   6.1 Если К.Данные меньше У.Данные
      6.1.2 У.Левый_потомок = К
   6.1 Если К.Данные больше У.Данные
      6.1.2 У.Правый_потомок = К

удаление(ROOT, К - узел который надо удалить)
1. Если К.Левый_потомок или К.Правый_потомок являются пустыми
   1.1 У=К
2.Иначе У=ПолучитьСледующийЭлемент(К)
3. Если У.Левый_потомок не является пустым
   3.1 Х=У.Левыйц_потомок
4. Иначе Х=У.Правый потомок
5.Если Х не является пустым, тогда Х.Родитель = У.Родитель
6.Если У.Родитель является пустым
   6.1 ROOT = Х
7. Иначе, если У равен У.Родитель.Левый_потомок, то У.Родитель.Левый_потомок = Х
8. Иначе, у.Родитель.Правый_потомок = Х
9. Если У не равен К, то К=У
10. Удаляем У